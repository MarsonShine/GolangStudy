/*
I/O 模型总共分为三种
1. 阻塞型I/O 模型
2. 非阻塞型I/O 模型
3. I/O 多路复用模型

阻塞型I/O
通过 read 系统函数调用对文件进行读写时，程序会阻塞，整体过程如下：
当执行 read 时，应用程序会从用户态进入操作系统内核态，内核会检查 FD（文件描述符）是否可读
当文件描述符存在数据时，操作系统会将准备好得数据复制给应用程序并让出控制权。

非阻塞型I/O
通过 read 系统函数调用对文件进行读写时，程序会立即返回并携带结果状态；EAGAIN 状态表示文件描述符还在等待缓冲区的数据；
然后程序会轮询调用 read 直到它的返回值大于 0，这时应用程序就可以读取操作系统的缓冲区数据进行操作。
进程在等待过程中可以执行其它任务，充分利用 CPU 资源

I/O 多路复用
主要是处理同一个事件循环中的多个 I/O 事件
主要用到的系统函数就是 select，类似于 poll 监听多个描述符是否可读或可写。最多监听 1024 个文件描述符

Go 的网络轮询器本质上是对 I/O 多路复用的二次封装
初始化轮询器
向轮询器中添加要监听的事件
触发对应的事件

Go 网络轮询器主要核心功能是就是“事件循环”：
1. Goroutine 让出线程并等待读写事件
2. 多路复用等待读写事件的返回

关于 network 底层知识移步：https://github.com/MarsonShine/Books/blob/master/CSAPP/docs/concurrency-program.md#io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8
*/