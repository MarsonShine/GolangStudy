/*
* Go 之所以在并发编程领域有强大的能力，主要是靠调度器。像一般实现并发，我们可以通过基于多进程来实现，但是由于每个进程都独占内存，所以交互起来非常不便，并且进程之间的上下文切换开销非常大
再者就是根据 I/O 多路复用原理来实现，但是此方法实现起来非常复杂
剩下就是利用多线程实现并发能力，多线程共享一个进程的虚拟内存空间，因此在切换上下文不需要开辟额外的虚拟内存空间，只需要复制数据、指针、寄存器等一些栈内存等上下文信息等，开销远比进程上下文切换要小

虽然线程上下文切换的开销比进程开销要低很多，但是实际上开销还是有的，Go 在这方面优化的更好，采用协程（Goroutine）的概念将开销减少了 80%。
Go 语言调度器通过使用与 CPU 核芯数量相等的线程来减少线程频繁发生切换的内存开销，同时在每个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载

基于工作窃取的多线程调度器将每个线程绑定给了每个 CPU 上，这些线程会被不同的处理器管理，不同的处理器通过工作窃取对任务进行在分配实现任务的平衡。
如何窃取？
Go 会在分段栈的机制上实现抢占，利用编译器在分段栈上插入函数，所有 Goroutine 在函数调用时都有机会进入运行时检查询问是否需要执行抢占。其行为步骤为：
1. 编译器在调用函数前插入函数 runtime.morestack
2. Go 会在执行 GC、系统监控程序运行一旦超过 10 ms时就发出抢占请求 StackPreempt
3. 当发生函数调用时，会先触发步骤 1 插入函数，并会检查该 Goroutine 的抢占请求字段是否为 StackPreempt
4. 如果抢占请求字段是 StackPreempt，则让出当前线程

基于信号量抢占调度：
这个抢占式模式只在发生 GC 时触发，其主要步骤：
1. 程序启动时注册信号处理函数
2. 在发生 GC 时触发挂起线程，标记当前 Goroutine 可以被抢占，并发送抢占信号
3. 操作系统接收该抢占信号执行中断程序预先注册的信号处理程序
4. 接收数据、指针以及程序计数器等上下文信息继续往下执行调用
5. 执行完并让出线程，调度器会继续选择其他 Goroutine 执行

Go 的调度器是一个 GMP 模型
G：表示 Goroutine，表示一个代执行的任务
M: 表示操作系统的线程，它由操作系统内核调度和管理
P: 表示处理器，可以被看作在线程上的本地调度器
*;/

