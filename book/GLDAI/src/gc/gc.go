/*
程序的数据和变量都会被分配到所在程序的虚拟内存中，内存区域主要分为两种：栈区（Stack）和堆区（Heap）。
调用的参数、返回值、指针以及局部变量都会被分配到栈上，这部分由编译器管理
内存管理一般由三个部分组成：应用程序（申请内存）、内存配分器（分配内存）、收集器

Go 的内存分配器采用线性分配器
在内存中维护一个指向内存地址的指针，当程序申请内存时，分配器只需要检查剩余的内存空间满足并返回分配的内存区域并修改对应的指针位置，然后偏移到对应的位置继续等待下一个 app 的内存申请请求
分配器主要分为两个，线性分配器和空闲链表分配器

线性分配器性能高，但是无法利用已经被释放过的内存，所以在发生垃圾回收时要注重要看这部分，是采用标记压缩算法还是分代回收算法又或是复制回收算法。
空闲链表分配器：顾名思义，数据结构是链表，所以会节省内存以及重用已释放的内存。这里面内存的方案又有四种：
1. 首次适应：从链表头部开始遍历，找到第一个内存大小满足的即分配
2. 循环首次适应：从上一次循环遍历分配的位置开始遍历，找到第一个内存大小满足即分配
3. 最优适应：从链表头遍历，找到内存大小最合适分配
4. 隔离适应：将链表分割为固定大小不同的多个链表，每个链表内存大小一致，申请内存时先找到满足条件的链表，在从链表中分配

Go在线性分配器的分配策略思想跟第四点类似

Go借鉴了线程缓存分配（Thread-Caching Malloc,TCMalloc）的设计思路实现的高速内存分配，核心理念是：使用多级缓存将对象根据内存大小分类，并按照类别实施不同的分配策略。
0-16b: 微对象
16b-32KB: 小对象
32KB-+∞: 大对象

分级缓存
内存分配会将不同类别的对象用不同的组件管理：
微对象：线程缓存（Thread Cache）
小对象：中心缓存（Central Cache）
大对象：页堆（Page Heap）

页堆是内存分配的主要数据结构（mheap），是一个全局的。该结构包含两个重要的部分：全局中心缓存列 central 字段和管理堆区内存区域的 arenas 字段

内存管理过程：
应用程序通过内存分配器（Allocator）申请在堆上开辟内存，而垃圾收集器（Collector）负责在堆回收内存。

关于垃圾收集器如何收集垃圾对象，主要是依靠垃圾回收（收集）算法
标记清除算法：分为标记阶段和清除阶段
标记：将从跟引用出发将存活的引用遍历标记起来
清除：遍历堆中所有对象，将没有标记的对象回收到空闲链表（单向）中。在之后进行分配时只需要遍历这个空闲链表即可。
并且在标记过程中其他程序都是不允许运行的，所以这个过程是会导致 STW（Stop The World）。
在标记阶段，还要必须保证在并发情况下是没问题的，所以需要借助内存屏障（Cache Barrier）技术，这又分为读屏障和写屏障。
屏障技术就是保证了在屏障之前的代码一定是在屏障之后的代码（因为编译器优化的关系，一般都会发生乱序执行指令的情况）

分配过程：这里简要说明以下如何分配内存的，当 mutator 申请 size 内存时，内存分配器会遍历这个空闲链表，如果刚好找到等同大小的分块则直接返回该分块；如果只找到比它大的（不能找小于 size 的），那就分割成 size 大小的块并将剩下的块返回给空闲链表。

缺点：所以这就导致了大量内存碎片化


*/