# Go 编译原理

Go 编译器将编译过程分为四个阶段：

- 词法和语法分析
- 类型检查和抽象语法树（AST）转换
- 通用静态单赋值（SSA）生成
- 生成机器码

## 词法和语法分析

这个阶段就是分析源代码代码，将源代码转换成 **Token 序列**，这是为了方便后面的处理和解析，这个分析的过程被称为**词法解析器（lexer）**。生成的 Token 序列就转交给**语法分析器**，也就是说以**源代码为输入给词法分析器，然后输出 Token 序列作为语法分析器的输入**。语法分析器按照预定好的**文法（Grammar）**将 Token 分析并进行规范，生成一个 SourceFile 结构：

```
SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" }
```

词法分析会但会一个序列（不含空格和换行等符号），语法分析会将这个序列转成抽象语法树（AST），每个 AST 对应一个 go 源代码文件。

## 类型检查和 AST 转换

从抽象语法树这种结构中对其进行**遍历**类型检查，检查项是固定的，检查的顺序如下：

1. 常量、类型和函数名及类型；
2. 变量的赋值和初始化；
3. 函数和闭包的主体；
4. 哈希键值对的类型；
5. 导入函数体；
6. 外部的声明；

make 关键字生成的类型，就是在类型检查阶段，编译器检测到 make(type) 中的特性，将 make 替换成对应类型的初始化方法，比如下面伪代码：

```
ch := make(chan int) -> ch := makeint()
slice := make(chan []int) -> slice := makeslice()
```

make 内部是由一个 `switch case` 语句做的转换。

在这个阶段，会对抽象语法树进行改写，做一些优化（除去一些不会执行的代码）、以及对代码进行优化提高执行效率，而且也会修改 `make`、`new` 等关键字对应节点的类型。

## 生成中间代码

为什么需要先翻译成中间代码而不是直接转换成目标语言（二进制），这是因为编译器会面临非常复杂的场景，很多编译器可能需要将源代码翻译成多种机器码，想要直接翻译这个是比较困难的，但是如果使用中间语言就可以简化了：

- 将编程语言直接翻译成目标机器语言拆分成两步：中间代码生成和机器码生成
- 中间代码是一种更接近机器语言的表示形式，对中间代码的优化和分析相比直接分析高级编程语言更容易；

当通过词法与语法分析和类型检查以及 AST 转换之后，就认为是当前的代码不存在语法和类型问题，接着编译器就会**将输入的抽象语法树生成中间代码**。在生成中间代码的过程中，SSA 会起到优化代码的作用。

静态单赋值意思就是说一个属性只能被赋值一次，如

```go
q := 1
q := 2
p := 3
```

像这种， SSA 就会将其优化为

```go
q := 2
p := 3
```

简而言之就是将源代码 `helloworld.go` 转换成中间代码 `helloworld.l` 接着将中间代码转换为 c 代码 `helloworld.yy.c` 最后编译成二进制文件。

## 生成机器码

最后就是将中间代码转换为底层 CPU 识别的机器码，不同的 CPU 类型生成的机器码有所不同。Go 不仅支持主流的 CPU，还支持将其生成 Wasm（WebAssembly） 格式，直接运行在浏览器中。